# -*- coding:utf-8 -*-import sys,os,os.path,time,struct,traceback,threading,datetime,calendar,stringfrom xml.dom import getDOMImplementationimport sqlite3import string,hashlibimport jsonfrom django.http import *from django.shortcuts import render_to_responseimport utils#import database.audio.core.models as cmimport audio.models as cm'''1.cross domain 时,采用jsonp返回数据，需要从request中提取callback名称，padding之后返回'''TEST = 0STORE_DIR = 'c:/leadtel/incoming'if sys.platform.find('linux')!=-1:	STORE_DIR='/svr/incoming'class ObjectStatus:	DISABLED    = 0	ENABLED     = 1	CLOSED      = 0	OPENED      = 1class MessageStatus:	UNACKED = 0	ACKED = 1class ServiceError:	ERROR_INTERNAL = 999class AppErrors:	USER_NOT_EXISTS         = 201 #用户不存在	USER_PASSWD_INCORRECT   = 202 #密码错误	DATA_INVALID            = 203 #数据不完整	NOT_ENOUGH_RIGHTS       = 204 #权限不够	PARAM_NOT_AVAILABLE     = 205 #参数错误	AUTH_FAILED             = 206 #认证失败	UNAUTHORIZED            = 207 #未认证	OBJECT_NOT_FOUND        =208	TOKEN_INVALID           = 209 #token dirty	OBJECT_IS_EXISTED       = 210 #对象已存在	USERNAME_INVALID        =211	PASSWD_INVALID          =212	CHANGE_NOT_ALLOW               =213	FILE_EXISTED            = 214 #文件已上传	TOO_LONG                =215class WebCallReturn:	SUCC = 0	FAILED = 1	def __init__(self,status = FAILED,	             ecode= ServiceError.ERROR_INTERNAL ,emsg=''):		self.status = status		self.ecode = ecode		self.emsg = emsg		self.result ={}		self.kvs={}	def assign(self,result):		self.result = result		return self	def httpResponse2(self):		'''			if jsonp:				callback_funcName = GET.get('callback')		'''		self.kvs['status'] = self.status		self.kvs['ecode'] = self.ecode		self.kvs['emsg'] = self.emsg		if self.result!=None:			self.kvs['result'] = self.result		return self#		self.kvs['status'] = self.status#		self.kvs['ecode'] = self.ecode#		self.kvs['emsg'] = self.emsg#		if self.result!=None:#			self.kvs['result'] = self.result#		if TEST:#			return self.kvs#		else:#			#return HttpResponse(json.dumps(self.kvs),mimetype='application/json')#			cb = 'Ext.data.JsonP.callback1(%s)'%json.dumps(json.dumps(self.kvs))#			return HttpResponse(cb,mimetype='application/json')	def httpResponse(self):		self.kvs['status'] = self.status		self.kvs['ecode'] = self.ecode		self.kvs['emsg'] = self.emsg		if self.result!=None:			self.kvs['result'] = self.result		if TEST:			return self.kvs		else:			return HttpResponse(json.dumps(self.kvs),mimetype='application/json')def SuccCallReturn():	return WebCallReturn(status=WebCallReturn.SUCC,ecode=0)def FailCallReturn(ecode=ServiceError.ERROR_INTERNAL,emsg=''):	if not emsg and ecode == ServiceError.ERROR_INTERNAL:		#emsg = traceback.format_exc()		print traceback.format_exc()	return WebCallReturn(ecode=ecode,emsg=emsg)def exception_catch(func):	def entering(*args,**kw):		try:			return func(*args,**kw)		except:			return WebCallReturn( emsg = traceback.format_exc()).httpResponse()	def exiting():		pass	return enteringdef webapi_call(func):	def entering(*args,**kw):		try:			r = args[0]			cb = GET(r,'callback')			result = func(*args,**kw)			if not cb or TEST:				return result.httpResponse2()			d = '%s(%s)'%(cb,json.dumps(json.dumps(result.kvs)))			return HttpResponse(d,mimetype='application/json')		except:			return FailCallReturn(emsg = traceback.format_exc()).httpResponse2()	def exiting():		pass	return enteringdef GET(r,name,default=None,post = False):	if not TEST:		r = r.POST	if not r.get(name):		return default	return r.get(name)QUERY_PAGESIZE = 100def getDataPagingParams(r):	start = int( GET(r,'page_start',0) )	size = int( GET(r,'page_size',QUERY_PAGESIZE))	return start,start+sizedef getSysSettings(key,default=None):	try:		r = cm.SysSettings.objects.get(key=key)		return r.value	except:		return defaultdef getStorePath(term=None,size=0):	'''		ymd/term_id/xxxx.mp3	'''#	root = 'c:/leadtel/incoming'	#root = utils.SimpleConfig().load('system.conf').get('store_path')	root =''	root = STORE_DIR	dt = utils.getToDayStr2()	path =  os.path.join(root,'%s/%s_%s'%(dt,term.id,term.id))	if not os.path.exists(path):		os.makedirs(path)	return path
