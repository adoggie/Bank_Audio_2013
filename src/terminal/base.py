# -*- coding:utf-8 -*-import sys,os,os.path,time,struct,traceback,datetime,ctypes,ctypes.wintypesimport stringimport utilsimport json,picklefrom dbconn import *import dbsqlimport cipherimport loggingfrom PyQt4 import QtCorefrom PyQt4 import QtGuifrom PyQt4.QtCore import *from PyQt4.QtGui import *ENCRYPT_PUBKEY='''-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCWEMTdAPU6nPhBCfGaCJmN4oIQ/L9Qxjdm9csTqRMDJVR5pk0BNxVAruFFKPnvYKeWczx815TUBBdMTYkS3iuZWHoFEsoBu+LAgdr1ZXPiw0zKVTlG+tfEJQICiYClu0xniNhEY9oPO8kGKoP1wdX3GuYKdYOQLg4OzQWYE6sMxwIDAQAB-----END PUBLIC KEY-----'''ENCRYPT_PRIVKEY='''-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQCWEMTdAPU6nPhBCfGaCJmN4oIQ/L9Qxjdm9csTqRMDJVR5pk0BNxVAruFFKPnvYKeWczx815TUBBdMTYkS3iuZWHoFEsoBu+LAgdr1ZXPiw0zKVTlG+tfEJQICiYClu0xniNhEY9oPO8kGKoP1wdX3GuYKdYOQLg4OzQWYE6sMxwIDAQABAoGBAIMYOyJmR9Tgc+89ZJaPlLVifwWgBvHld1i2uKWAOl+xKM7s/LBnEmXjYGAun8kCwuSn3tug6R8eQ8wgn/Kfq61/sEfTl7G07P/toUTR41hnmkESLsCj/DW+B45EqhJlVU5BInfhTKHo/GJHSJJM4qzGnFpvzboRcxJ+OWjkUoahAkEAuc2xgH4SZzkH3xp2v45xVKpJ+OXuGZdlctLy1+hKN1RtFoXrD8P8sDBNfFjJ0g9+3qIU31HcuvXnKk25MCJVBQJBAM7CnUeSXQ68MYhB9Ze2SShwWLSusgdPB1BOhWrWVguLblX8vibngFJDH4HsmZH+1qGQ2IoVrvIvnw22NhMTxFsCQAJYOSQw8xSAYLwM/nCeYIm7+GD+rcl+4pXXWZ8l3EHke9fr6rJxO7ARe/jUuf8/mM9AZlkHFGz7i2Y6Qtr7o+0CQDnI0kQKd8+CcSVvqb+4xkFzBJeaq063m4eqKkdtl6aqVS/a7xnYYVicQdYB1fmji0CkRqBw5u/wtzcR0ZMLVzkCQDYl+2GunTk3G+SeWxQdQKjggPmyHwiX9UYAOdJs5/vLvjARuaAJ87jZjS0jB48WPnRNITjbCn9MBncEB7asch4=-----END RSA PRIVATE KEY-----'''class CallReturn:	def __init__(self,succ =True,msg='',result=None,code=0):		self.succ = succ		self.errcode = code  #没错误 		self.msg = msg		self.result = result  #携带任何数据返回s	#def __str__(self):	#	return 'succ:%s,errcode:%s,msg:%s,result:%s'%(self.succ,self.errcode,self.msg,self.result)	def __unicode__(self):		return 'succ:%s,errcode:%s,msg:%s,result:%s'%(self.succ,self.errcode,self.msg,self.result)PROFILE = 'local.profile'ENCRYPT_KEY = 'leadtel.'#APP_VER='v0.1.0.1'#APP_VER='v0.1.2.0'#APP_VER='v0.1.3.0'#APP_VER='v0.1.3.1'#APP_VER='v0.1.3.2'#APP_VER='v0.1.3.5'#APP_VER='v0.1.3.6'#APP_VER='v0.1.3.7'#APP_VER='v0.1.4.0'#APP_VER='v0.1.4.1'#APP_VER='v0.1.4.2'#APP_VER='v0.1.5.0'#APP_VER='v0.1.5.1'#APP_VER='v0.1.5.2'#APP_VER='v0.1.5.3'#APP_VER='v0.1.6.0'#APP_VER='v0.1.6.1'#APP_VER='v0.1.6.2'#APP_VER='v0.1.6.3'#APP_VER='v0.1.7.0'#APP_VER='v0.1.7.2'#APP_VER='v0.1.7.3'#APP_VER='v0.1.7.4'#APP_VER='v0.2.0.0'APP_VER='1.0.1.0'BUILD_TIME='2013/12/8''''1.0.0.0	1. 来电弹屏窗口改为QQ、飞信的即时消息一样，在右下角弹出消息框，提示新来电的号码、姓名那三样东西，来电振铃如果用户没有摘机（未接电话），则电话机上报一个未接命令（陈中明增加），用来实现弹屏窗自动消失。	2. 摘机后是否弹出备注信息框，可以在“系统设置”中设置（默认是不弹出），如果选择自动弹出，则像以前一样，来电框消失，备注框弹出；备注框中增加“历史通话备注”（时间、备注两个内容）, 如果不选自动弹出，则来电弹屏框始终放在右下角，挂机后再消失，这样，客户经理可以随时点击弹出备注框。(来电框中增加启动备注框的按钮)	3. 终端软件更新：如果服务器增加了新版本，则终端软件每次启动检查到有新版本时，提示点击下载，最好能自动安装。	4. 锁屏密码、登录密码必须是字母+数字，并且3个月强制更新，否则不给登录。该功能在终端软件比较，如果超过3个月就强行提示更新，如果不更新就不启动软件。	5. 客户的属性可能要增加一个自定义的标签属性，客户经理自己标注的东西，（比如说易投诉客户、骚扰型客户、急需处理的客户）	6. 销售、日常沟通这个类别他们会增加项目，这个要等他们通知。v0.1.2.0    2013.5.24	磁盘空间利用报警	增加客户信息字段	增加客户字段检索	状态报警提示，trayicon更替'v0.1.3.0'	增加话机密码识别，密码不正确不上传录音文件0.1.3.1	1.删除日志Tab	2.删除第二服务器配置框	3.直接上传spx文件到服务器	4.修改保存客户信息时错误将空的电话号码关联到已有的某一条语音记录0.1.3.2	1.上传临时文件命名 .spx_ 改为 ._spx_ , 避免同步线程同步未完成上传的数据0.1.3.5	1.增加登陆密码修改	2.注册表自动运行代码	修改导入导出客户资料	当接通之后把拨号窗口关闭	3.more...0.1.3.6	1.	软件中某一个客户信息手动删除掉之后，好像显示没有了，但软件还有信息，比如：话机摘机，拨号“8。。。”软件自动弹屏出来一个人名abc，但abc我们已经删除过了。。。	2.	点击“拨号”，粘贴一个电话号码，下面人名没有匹配出来。（昨天交行说的问题）	3.	客户信息的导入：excel编辑的客户信息，客户类别导入后都变成“普通客户”了	4.	软件中客户信息不支持批量删除，建议改为，软件中支持多选条，可以删除多条。	发现弹出的窗口中号码、客户名称都没有，通话时长都是11秒？原来的备注信息也没有？（后来反复测试，发现只要播放过某一条录音，以后弹出的窗口信息就是那条录音的内容，和选择的那条录音不对应。）	5.	来电如果没有号码的话，应该弹屏是空的号码，对应空的姓名；但现在是弹屏是空的号码，但有对应一个人的名字。。。0.1.3.7	1. login增加 appver参数		storeadater.webapi记录appver和登陆时间		audio.module增加appver字段	2. spx解析hdr信息，phone字段中的*#按键都转换为#字符	3. 键盘拨号要增加动态按键匹配客户信息		audioNote窗口中匹配上多个客户时，提供客户列表combox选择0.1.4.0	1. 修改多处bug	2.支持一电话号码对应多客户的功能		增加表 core_audiomapclient		更多..0.1.4.1	1. 客户信息导出修正导出已删除客户的问题	2. 修正软件拨号显示客户名称问题	3. 语音备注窗体，保存时，未关联客户的语音记录全部关联，已关联的只更新当前记录0.1.4.2 	1. udp log fixed bug	2. log输出unicode转换成gbk0.1.5.0	1.诸多问题修复		list: 录音测试_2013.7.12.doc0.1.5.1	1.不同客户相同号码拨号显示错误问题 fixed0.1.5.2	1.来电弹屏，去掉“通话时间”。。。。因为这时候还没摘机呢。。	2.去电或者来电,备注框弹屏之后，如果没有点击“保存”，则“通话记录”中人名没有保存下来，这时候，人名应该记下来 (fixed)0.1.5.3	1.更新form_dial.py拨号窗体中，相同电话号码不同客户选择显示问题0.1.6.0	1. form_audio_note.py 修复保存电话号码时没有将新号码写入客户信息的bug	    设置 edtPhone 电话号码编辑框为只读0.1.6.1	1. 播放时音频spx转wav( convert.py） 用subprocess.call替代os.system(),避免播放时显示控制台界面0.1.6.2	1. 修正 程序最小化tray运行，检测到usb设备离线，不显示警告提示窗口，防止ui线程由于未取消提示框而导致卡死0.1.6.3	1. tray运行时，来电之后关闭备注窗体，无法再次显示主界面，貌似ui线程已退出所致，故 设置self.setQuitOnLastWindowClosed(False)	   防止最后一个窗体关闭之后导致ui线程得不到反应(这个还得多次测试才行)	2. 修改 utils.py的Logger类，增加检测是否相同目录下存在 logdump.yes文件，存在则将日志输出，否则就屏蔽日志输出 ，默认(不输出)0.1.7.0	1.	“通话记录”中搜索条件的“录音类型”修改名称为“来去电类型”，相应的列表也改为“来去电类型”。	2.	“通话记录”中搜索条件的“通话内容”修改名称为“通话类型”，列表中没有该列，请增加；	3.	“通话记录”中增加输出excel的功能。0.1.7.2	1.启动设置工作目录为当前exe的所在目录，保证系统启动加载运行app时工作目录正常0.1.7.3	1. client导入，数字输入为float类型时转换为integer类型，防止小数点产生0.1.7.4	1.在导出或导入时，由于选择输出目录，导致当前进程的工作目录被改变，所以在处理输出文件时需要强制指定目录	 usbcmd.py 输出 usb.props时指定app/bin目录	 dbsql.py 定位 system.lib时指定app/bin/system.lib	2.修复修改语音日志内容之后保存时 刷新录音记录字段错误的问题APP_VER='v0.2.0.0'	1.增加锁屏功能，锁屏对话框、锁屏时间控制、锁屏密码设置0.2.1.0	1.更新锁屏功能：开机锁屏1.0.0.0	1. 来电弹屏窗口改为QQ、飞信的即时消息一样，在右下角弹出消息框，提示新来电的号码、姓名那三样东西，来电振铃如果用户没有摘机（未接电话），则电话机上报一个未接命令（陈中明增加），用来实现弹屏窗自动消失。	2. 摘机后是否弹出备注信息框，可以在“系统设置”中设置（默认是不弹出），如果选择自动弹出，则像以前一样，来电框消失，备注框弹出；备注框中增加“历史通话备注”（时间、备注两个内容）, 如果不选自动弹出，则来电弹屏框始终放在右下角，挂机后再消失，这样，客户经理可以随时点击弹出备注框。(来电框中增加启动备注框的按钮)	3. 终端软件更新：如果服务器增加了新版本，则终端软件每次启动检查到有新版本时，提示点击下载，最好能自动安装。	4. 锁屏密码、登录密码必须是字母+数字，并且3个月强制更新，否则不给登录。该功能在终端软件比较，如果超过3个月就强行提示更新，如果不更新就不启动软件。	5. 客户的属性可能要增加一个自定义的标签属性，客户经理自己标注的东西，（比如说易投诉客户、骚扰型客户、急需处理的客户）	6. 销售、日常沟通这个类别他们会增加项目，这个要等他们通知。1.0.1.0	1. 客户信息中的客户自定义标签字段正确显示问题	2.客户信息排序问题。（因为地址、邮编、邮件的优先级比较低，需要放在最后，然后把客户类别、归属机构、备注说明、以及自定义标签放到地址、邮编、邮件的前面。）	3.历史备注显示的不是最近一条语音备注信息。打开语音备注窗口默认右边的滚动条在最下方，可以改成滚动条默认在最上方，这样显示的历史备注为最近一条1.0.2.0    更新若干问题，见  #语音平台测试MP3版_2012.12.27.doc1.0.3.0	1.修正通话时多次录音备注修改只显示最近一条备注的问题	2.修改通话提示窗口文本颜色为蓝色1.0.3.1	1.更新软件新版本提示内容1.0.3.2 20014.1.14	1. 修正服务器读取spx hdr头部日期的问题 , createtime1.0.3.3 2014.3.11	1.convert.py ffmpeg增加 -y 参数'''APP_VER='1.0.3.3'BUILD_TIME='2004/03/11'class AppConst:	RECORD_INCALL = 0   #呼入	RECORD_OUTCALL = 1  #呼出	RECORD_PRESENT = 2  #现场录音	WIN_TITLE_BC = u'语音通信程序'.encode('gbk')	PHONE_DIAL = 1	PHONE_HANGON = 2	PHONE_HANGUP = 3	PHONE_INCOMING = 4	PHONE_RECORDING = 5	ARCHIVE_NOTE_TYPE_ALL = 0	ARCHIVE_NOTE_TYPE_NORMAL= 1     #日常沟通	ARCHIVE_NOTE_TYPE_SALE = 2      #销售	ARCHIVE_NOTE_TYPE_OTHER = 99    #其他	MIN_DISK_FREESPACE = 2  #最小剩余空间限制	APP_NAME_AUTORUN = 'audioTerm'	CLIENT_TYPES= ( (0,u'普通客户'),	                (1,u'交银客户'),					(2,u'沃德客户'),					(3,u'私人银行')	              )	CLIENT_DELETED_MARKER = '<<DELETE>>'	APP_FONT_NAME = 'Microsoft YaHei'	APP_FONT_FILE = ''	@staticmethod	def getClientTypeId(name):		rc = 0		for t in AppConst.CLIENT_TYPES:			if t[1] == name:				rc = t[0]				break		return rc	@staticmethod	def getClientTypeName(type):		name=''		for k,v in AppConst.CLIENT_TYPES:			if type == k:				name = v				break		return name	tone_types={			#ARCHIVE_NOTE_TYPE_ALL:u'全部',			ARCHIVE_NOTE_TYPE_NORMAL:u'日常沟通',		    ARCHIVE_NOTE_TYPE_SALE:u'销售',		    ARCHIVE_NOTE_TYPE_OTHER:u'其他'		}	@staticmethod	def valueToStr(val):		#table={		#	AppConst.ARCHIVE_NOTE_TYPE_ALL:u'全部',		#	AppConst.ARCHIVE_NOTE_TYPE_NORMAL:u'日常沟通',		#    AppConst.ARCHIVE_NOTE_TYPE_SALE:u'销售',		#    AppConst.ARCHIVE_NOTE_TYPE_OTHER:u'其他'		#}		table = AppConst.tone_types		if table.has_key(val):			return table[val]		return ''class COPYDATASTRUCT(ctypes.Structure):	_fields_ = [		('dwData', ctypes.wintypes.LPARAM),		('cbData', ctypes.wintypes.DWORD),		('lpData', ctypes.c_void_p)	]PCOPYDATASTRUCT = ctypes.POINTER(COPYDATASTRUCT)SETTINGS={	'webserver':    'localhost:8000',	'commserver':   'localhost:8090',	'user':         'test',	'passwd':       '111111',	'employee':     'scott',	'address':      'shanghai,pudong',	'phone':        '13916624477',	'addition':     '',	'startWithOs':  1,      #随系统启动自动运行	'runbackground':  1,     #后台自动运行,不显示主窗体	'version':'0.1.0.0',	'current_audio_serial':0,    #当前话机文件索引编号	'phone_passwd':'0000',   #默认话机密码    'memo_auto_show':1,}class TermApp:	def __init__(self):		self.token = ''		self.settings={}		self.app_path = u'c:/leadtel'#		self.app_path = u'c:/leadtel_领旗帜'		path = qApp.applicationDirPath().toUtf8().data().decode('utf-8')		if path.lower().find(u'python')==-1:			self.app_path = path.replace('/bin','')		print 'app_path:',self.app_path		self.db = None#		self.settings['passwd'] = cipher.encrypt_des(ENCRYPT_KEY,self.settings['passwd'])		self.running = True		self.mainwindow = None		# self.last_tracktime = 0		self.lock_cycle = 60		self.init()	def init_db(self):		self.db = dbsql.SqlPrepare()	def init(self):		try:			logfile = os.path.join(self.getBinPath(),'system.log')			if os.path.exists(logfile):				size = os.path.getsize(logfile)				if size > 1024*1024*20:					back = os.path.join(self.getBinPath(),'system.log.%s'%(int(time.time())))					os.rename(logfile,back)			path = os.path.join(self.getBinPath(),PROFILE)#			print path			if os.path.exists(path):				f = open(path)				s = f.read()				f.close()				self.settings = pickle.loads(s)#			self.settings['passwd'] = self.decryptValue(self.settings['passwd'])#			print self.settings			# logging.basicConfig(level=logging.DEBUG,			#                     format='%(asctime)s  %(levelname)-8s %(message)s',			#                     datefmt='%m-%d %H:%M',			#                     filename=logfile,			#                     filemode='a')			# console = logging.StreamHandler()			# console.setLevel(logging.INFO)			# formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')			# console.setFormatter(formatter)			# logging.getLogger().addHandler(console)			if not os.path.exists(self.getBinPath()):				os.mkdir(self.getBinPath())			if not os.path.exists(self.getTempPath()):				os.mkdir(self.getTempPath())			if not os.path.exists(self.getAudioUploadPath()):				os.mkdir(self.getAudioUploadPath())			if not os.path.exists(self.getAudioStorePath()):				os.mkdir(self.getAudioStorePath())			fontpath = self.getBinPath()+'/MSYH.TTF'			QtGui.QFontDatabase.addApplicationFont(fontpath)			self.lock_cycle = int(self.getSettingsValue('lock_cycle','864000'))			self.last_tracktime =0 # time.time()			self.last_tracktime = time.time()			if self.lock_cycle < 3600*24: #锁屏时间过长，视为关闭锁屏,否则认为打开锁屏				self.last_tracktime = 0 #如果打开锁屏，启动即刻锁屏 2013.12.11			self.locked = True			self.locked = False			print 'lock_cycle:',self.lock_cycle			#2013.11.7 读取system.conf中定义的语音类型			#tone_types=1:日常沟通,2:销售,99:其他			text = self.getSystemConfig('tone_types','')			if text:				AppConst.tone_types ={}				items = text.strip().split(',')				items = map(string.strip,items)				for item in items:					val,name = item.split(':')					val = val.strip()					name = name.strip()					AppConst.tone_types[int(val)]=name.decode('utf-8') #补充类型		except:			traceback.print_exc()	def isReachTimeLock(self):		# print time.time() - self.last_tracktime , self.lock_cycle		return time.time() - self.last_tracktime > self.lock_cycle	def timeLocked(self):		# self.locked = self.isReachTimeLock()		return self.locked	def timeLock(self):		self.locked = True		self.last_tracktime = 0	def timeUnlock(self):		self.locked = False		self.last_tracktime = time.time()		# print 'do unlock..'	def getLockPasswd(self):		return self.getSettingsValue('lock_passwd','111111')	def setLockPasswd(self,passwd):		self.setSettingsValue('lock_passwd',passwd)		#写入锁屏密码修改时间		self.setSettingsValue('lock_passwd_modify_time',str(int(time.time())))		self.saveSettings()	def setTimeLockCycle(self,cycle):		self.lock_cycle = cycle		self.setSettingsValue('lock_cycle',str(cycle))		self.saveSettings()	def getTimeLockCycle(self):		return self.lock_cycle	def getSystemConfig(self,cfg,default=None):		cfgfile = os.path.join(self.getBinPath(),'system.conf')		return utils.SimpleConfig().load(cfgfile).get(cfg,default)	def getLogger(self):		import utils		return utils.Logger.instance()	def decryptValue(self,d):		return cipher.decrypt_des(ENCRYPT_KEY,d)	def encryptValue(self,d):		return cipher.encrypt_des(ENCRYPT_KEY,d)	def getBinPath(self):		return self.app_path+'/bin'	def getPath(self):		return self.app_path	def getDB(self):		return self.db	def getTempPath(self):		return self.app_path+'/temp'	def getAudioUploadPath(self):		return self.app_path+'/upload'	def getAudioStorePath(self):		return self.app_path+'/media'	def getSettings(self):		return self.settings	def setSettingsValue(self,key,value):		self.settings[key] = value	def getSettingsValue(self,key,value=''):		return self.settings.get(key,value)	def saveSettings(self):		try:#			self.settings['passwd'] = self.encryptValue(self.settings['passwd'])			path = os.path.join(self.getBinPath(),PROFILE)			f = open(path,'w')			d = pickle.dumps(self.settings)			f.write(d)			f.close()			print path		except:			traceback.print_exc()	def saveSettingsValue(self,key,value):		self.setSettingsValue(key,value)		self.saveSettings()	handle = None	@staticmethod	def instance():		if not TermApp.handle:			TermApp.handle = TermApp()		return TermApp.handle	def getToken(self):		return self.token#	def getFileServerAddress(self):#		return self.settings.get('file_server_address')##	def getCommServerAddress(self):#		return self.settings.get('comm_server_address')def getApp():	return TermApp.instance()if __name__=='__main__':	f = open(PROFILE,'w')	d = pickle.dumps(SETTINGS)	f.write(d)	f.close()#	getApp().saveSettings()